const run=()=>{(()=>{"use strict";var e,n,t,i,s,a,l,o,r;!function(e){e.On="on",e.Off="off",e.Auto="auto"}(e||(e={})),function(e){e.Off="off",e.Fullscreen="fullscreen",e.On="on"}(n||(n={})),function(e){e.Visible="visible",e.Hidden="hidden"}(t||(t={})),function(e){e.Error="error",e.Warn="warn",e.Info="info",e.Debug="debug",e.Trace="trace"}(i||(i={})),function(e){e.Window="window",e.Opaque="opaque",e.Transparent="transparent",e.Direct="direct",e.Gpu="gpu"}(s||(s={})),function(e){e.WebGpu="webgpu",e.WgpuWebgl="wgpu-webgl",e.Webgl="webgl",e.Canvas="canvas"}(a||(a={})),function(e){e.On="on",e.RightClickOnly="rightClickOnly",e.Off="off"}(l||(l={})),function(e){e.Allow="allow",e.Confirm="confirm",e.Deny="deny"}(o||(o={})),function(e){e.All="all",e.Internal="internal",e.None="none"}(r||(r={}));const u={allowScriptAccess:!1,parameters:{},autoplay:e.Auto,backgroundColor:null,letterbox:n.Fullscreen,unmuteOverlay:t.Visible,upgradeToHttps:!0,compatibilityRules:!0,favorFlash:!0,warnOnUnsupportedContent:!0,logLevel:i.Error,showSwfDownload:!1,contextMenu:l.On,preloader:!0,splashScreen:!0,maxExecutionDuration:15,base:null,menu:!0,salign:"",forceAlign:!1,quality:"high",scale:"showAll",forceScale:!1,frameRate:null,wmode:s.Opaque,publicPath:null,polyfills:!0,playerVersion:null,preferredRenderer:null,openUrlMode:o.Allow,allowNetworking:r.All,openInNewTab:null,socketProxy:[],fontSources:[],defaultFonts:{}},c=Object.assign(Object.assign({},u),{ruffleEnable:!0,ignoreOptout:!1,autostart:!1});let p,m,d,h,f,g;function y(e){return new Promise(((n,t)=>{e((e=>{const i=chrome.runtime.lastError;i?t(i):n(e)}))}))}function w(e){return{clear:()=>y((n=>e.clear(n))),get:n=>y((t=>e.get(n||null,t))),remove:n=>y((t=>e.remove(n,t))),set:n=>y((t=>e.set(n,t)))}}if("undefined"!=typeof chrome)p=chrome.i18n,m={local:w(chrome.storage.local),sync:w(chrome.storage.sync),onChanged:{addListener:e=>chrome.storage.onChanged.addListener(e)}},d={reload:e=>y((n=>chrome.tabs.reload(e,void 0,n))),query:e=>y((n=>chrome.tabs.query(e,n))),sendMessage:(e,n,t)=>y((i=>chrome.tabs.sendMessage(e,n,t||{},i)))},h=chrome.runtime,f=()=>y((e=>chrome.tabs.create({url:"/options.html"},e))),g=()=>y((e=>chrome.tabs.create({url:"/player.html"})));else{if("undefined"==typeof browser)throw new Error("Extension API not found.");p=browser.i18n,m=browser.storage,d=browser.tabs,h=browser.runtime,f=()=>browser.runtime.openOptionsPage(),g=()=>y((e=>browser.tabs.create({url:"/player.html"})))}async function b(){const e=await m.sync.get();return Object.assign(Object.assign({},c),e)}const _=[],T=Math.floor(1e11*Math.random());function v(e){const n={to:`ruffle_page${T}`,index:_.length,data:e};return window.postMessage(n,"*"),new Promise(((e,n)=>{_.push({resolve:e,reject:n})}))}(async()=>{const e=await b(),n=await async function(){const e=await b(),n=c;for(const t in n)t in e&&n[t]===e[t]&&delete e[t];return e}(),t=function(){if(document.documentElement.hasAttribute("data-ruffle-optout"))return!0;try{if(window.top&&window.top.document&&window.top.document.documentElement&&window.top.document.documentElement.hasAttribute("data-ruffle-optout"))return!0}catch(e){e instanceof Error?e.message:String(e)}return!1}(),i=!("FOO"!==document.createElement("foo").tagName)&&e.ruffleEnable&&(e.ignoreOptout||!t);if(h.onMessage.addListener(((n,s,a)=>i?(v(n).then((n=>{a({loaded:!0,tabOptions:e,optout:t,data:n})})),!0):(a({loaded:!1,tabOptions:e,optout:t}),!1))),!i)return;const s=(chrome||browser).runtime.getManifest().permissions;(null==s?void 0:s.includes("scripting"))||function(e){const n=document.createElement("script");n.textContent=e,(document.head||document.documentElement).append(n)}('/******/ (() => { // webpackBootstrap\n/******/ \t"use strict";\nvar __webpack_exports__ = {};\n\n;// CONCATENATED MODULE: ../core/dist/flash-identifiers.js\nconst FLASH_MIMETYPE = "application/x-shockwave-flash";\nconst FUTURESPLASH_MIMETYPE = "application/futuresplash";\nconst FLASH7_AND_8_MIMETYPE = "application/x-shockwave-flash2-preview";\nconst FLASH_MOVIE_MIMETYPE = "application/vnd.adobe.flash.movie";\nconst FLASH_ACTIVEX_CLASSID = "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000";\n\n;// CONCATENATED MODULE: ../core/dist/plugin-polyfill.js\n\n/**\n * Replacement object for `MimeTypeArray` that lets us install new fake mime\n * types.\n *\n * Unlike plugins we can at least enumerate mime types in Firefox, so we don\'t\n * lose data.\n *\n * We also expose a method called `install` which adds a new plugin. This is\n * used to falsify Flash detection. If the existing `navigator.mimeTypes` has an\n * `install` method, you should not use `RuffleMimeTypeArray` as some other\n * plugin emulator is already present.\n */\nclass RuffleMimeTypeArray {\n    constructor(mimeTypes) {\n        this.__mimeTypes = [];\n        this.__namedMimeTypes = {};\n        if (mimeTypes) {\n            for (let i = 0; i < mimeTypes.length; i++) {\n                this.install(mimeTypes[i]);\n            }\n        }\n    }\n    /**\n     * Install a MIME Type into the array.\n     *\n     * @param mimeType The mime type to install\n     */\n    install(mimeType) {\n        const index = this.__mimeTypes.length;\n        this.__mimeTypes.push(mimeType);\n        this.__namedMimeTypes[mimeType.type] = mimeType;\n        this[mimeType.type] = mimeType;\n        this[index] = mimeType;\n    }\n    item(index) {\n        // This behavior is done to emulate a 32-bit uint,\n        // which browsers use.\n        return this.__mimeTypes[index >>> 0];\n    }\n    namedItem(name) {\n        return this.__namedMimeTypes[name];\n    }\n    get length() {\n        return this.__mimeTypes.length;\n    }\n    [Symbol.iterator]() {\n        return this.__mimeTypes[Symbol.iterator]();\n    }\n}\n/**\n * Equivalent object to `Plugin` that allows us to falsify plugins.\n */\nclass RufflePlugin extends RuffleMimeTypeArray {\n    constructor(name, description, filename) {\n        super();\n        this.name = name;\n        this.description = description;\n        this.filename = filename;\n    }\n}\n/**\n * Replacement object for `PluginArray` that lets us install new fake plugins.\n *\n * This object needs to wrap the native plugin array, since the user might have\n * actual plugins installed. Firefox doesn\'t let us enumerate the array, though,\n * which has some consequences. Namely, we can\'t actually perfectly wrap the\n * native plugin array, at least unless there\'s some secret "unresolved object\n * property name handler" that I\'ve never known before in JS...\n *\n * We can still wrap `namedItem` perfectly at least.\n *\n * We also expose a method called `install` which adds a new plugin. This is\n * used to falsify Flash detection. If the existing `navigator.plugins` has an\n * `install` method, you should not use `RufflePluginArray` as some other plugin\n * emulator is already present.\n */\nclass RufflePluginArray {\n    constructor(plugins) {\n        this.__plugins = [];\n        this.__namedPlugins = {};\n        for (let i = 0; i < plugins.length; i++) {\n            this.install(plugins[i]);\n        }\n    }\n    install(plugin) {\n        const index = this.__plugins.length;\n        this.__plugins.push(plugin);\n        this.__namedPlugins[plugin.name] = plugin;\n        this[plugin.name] = plugin;\n        this[index] = plugin;\n    }\n    item(index) {\n        // This behavior is done to emulate a 32-bit uint,\n        // which browsers use. Cloudflare\'s anti-bot\n        // checks rely on this.\n        return this.__plugins[index >>> 0];\n    }\n    namedItem(name) {\n        return this.__namedPlugins[name];\n    }\n    refresh() {\n        // Nothing to do, we just need to define the method.\n    }\n    [Symbol.iterator]() {\n        return this.__plugins[Symbol.iterator]();\n    }\n    get length() {\n        return this.__plugins.length;\n    }\n}\n/**\n * A fake plugin designed to trigger Flash detection scripts.\n */\nconst FLASH_PLUGIN = new RufflePlugin("Shockwave Flash", "Shockwave Flash 32.0 r0", "ruffle.js");\nFLASH_PLUGIN.install({\n    type: FUTURESPLASH_MIMETYPE,\n    description: "Shockwave Flash",\n    suffixes: "spl",\n    enabledPlugin: FLASH_PLUGIN,\n});\nFLASH_PLUGIN.install({\n    type: FLASH_MIMETYPE,\n    description: "Shockwave Flash",\n    suffixes: "swf",\n    enabledPlugin: FLASH_PLUGIN,\n});\nFLASH_PLUGIN.install({\n    type: FLASH7_AND_8_MIMETYPE,\n    description: "Shockwave Flash",\n    suffixes: "swf",\n    enabledPlugin: FLASH_PLUGIN,\n});\nFLASH_PLUGIN.install({\n    type: FLASH_MOVIE_MIMETYPE,\n    description: "Shockwave Flash",\n    suffixes: "swf",\n    enabledPlugin: FLASH_PLUGIN,\n});\n/**\n * Install a fake plugin such that detectors will see it in `navigator.plugins`.\n *\n * This function takes care to check if the existing implementation of\n * `navigator.plugins` already accepts fake plugin entries. If so, it will use\n * that version of the plugin array. This allows the plugin polyfill to compose\n * across multiple plugin emulators with the first emulator\'s polyfill winning.\n *\n * @param plugin The plugin to install\n */\nfunction installPlugin(plugin) {\n    if (!("install" in navigator.plugins) || !navigator.plugins["install"]) {\n        Object.defineProperty(navigator, "plugins", {\n            value: new RufflePluginArray(navigator.plugins),\n            writable: false,\n        });\n    }\n    const plugins = navigator.plugins;\n    plugins.install(plugin);\n    if (plugin.length > 0 &&\n        (!("install" in navigator.mimeTypes) || !navigator.mimeTypes["install"])) {\n        Object.defineProperty(navigator, "mimeTypes", {\n            value: new RuffleMimeTypeArray(navigator.mimeTypes),\n            writable: false,\n        });\n    }\n    const mimeTypes = navigator.mimeTypes;\n    for (let i = 0; i < plugin.length; i += 1) {\n        mimeTypes.install(plugin[i]);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/plugin-polyfill.ts\n// This file is compiled and then injected into content.ts\'s compiled form.\n\ninstallPlugin(FLASH_PLUGIN);\n\n/******/ })()\n;'),await function(e){const n=document.createElement("script"),t=new Promise(((e,t)=>{n.addEventListener("load",(()=>e())),n.addEventListener("error",(e=>t(e)))}));return n.charset="utf-8",n.src=e,(document.head||document.documentElement).append(n),t}(h.getURL(`dist/ruffle.js?id=${T}`)),window.addEventListener("message",(e=>{if(e.source!==window)return;const{to:n,index:t,data:i}=e.data;if(n===`ruffle_content${T}`){const e=null!==t?_[t]:null;if(e)_[t]=null,e.resolve(i);else if(void 0!==i.type)switch(i.type){case"open_url_in_player":chrome.runtime.sendMessage({type:"open_url_in_player",url:i.url})}}})),await v({type:"load",config:Object.assign(Object.assign({},n),{autoplay:e.autostart?"on":"auto",unmuteOverlay:e.autostart?"hidden":"visible",splashScreen:!e.autostart})})})()})()};chrome.storage.local.get(["ruffleEnable"],(e=>{e.ruffleEnable&&run()}));